;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   Вс мар 11 2018
; Processor: ATmega128
; Compiler:  AVRASM (Proteus)
;====================================================================

;====================================================================
; DEFINITIONS
;====================================================================
.def temp = R16
.def temp2 = R17
.def keyboard = R18
.def temp3 = R19
.def temp_ret = R20
.def prev_keyboard_state = R21
.def rMIN = R22
.def rSEC = R23
.def rMILLIS = R24
.def temp4 = R26
;====================================================================
; VARIABLES
;====================================================================

;====================================================================
; RESET and INTERRUPT VECTORS
;====================================================================

      ; Reset Vector
      rjmp  Start

;====================================================================
; CODE SEGMENT
;====================================================================

Start:
      ; Write your code here
      setup_ports:
      out_ports:
	 ldi temp, 0xFF
	 out DDRD, temp
	 out DDRE, temp
	 out DDRC, temp
      in_ports:
	 ldi temp, 0x00
	 out DDRB, temp
	 ldi temp, 0xFF
	 out PORTB, temp
	 
      out_EE_KEYBOARD:
	 ldi keyboard, 0xEE
	 out PORTC, keyboard

      out_E_SEG1:
      ldi temp, 0x79
      out PORTD, temp
      out_r_SEG0:
      ldi temp, 0x50
      out PORTE, temp
      
      ldi rMIN, 0x12
      ldi rSEC, 0x34
      ldi rMILLIS, 0x05
Loop:
      call CHECK_KEYBOARD_DOWN
      call DISPLAY_ALL
      rjmp  Loop

;====================================================================
; MAIN PROCEDURES
;====================================================================
CHECK_KEYBOARD_DOWN:
      call GET_KEYBOARD_PRESSED
      cpi temp_ret, 0x00
      breq keyboard_not_pressed
      keyboard_pressed:
	    cp temp_ret, prev_keyboard_state
	    breq keyboard_not_pressed
	    keyboard_down_event:
		  mov temp, temp_ret
		  call CONVERT_temp_TO_KBCODE
		  call PRESSED_temp_KEY
      keyboard_not_pressed:
      
      mov prev_keyboard_state, temp_ret
ret
PRESSED_temp_KEY:
      cpi temp, 0x0A
      brlo digit_key
      sys_key:
	    cpi temp, 0x0F
	    breq clear_key
	    cpi temp, 0x0A
	    breq add_key
	    cpi temp, 0x0C
	    breq mul_key
	    cpi temp, 0x0E
	    breq equal_key
	    other_key:
		  jmp end_pressed_key
	    clear_key:
		  jmp end_pressed_key
	    add_key:
		  jmp end_pressed_key
	    mul_key:
		  jmp end_pressed_key
	    equal_key:
		  jmp end_pressed_key
      jmp end_pressed_key
      digit_key:
      end_pressed_key:
ret
DISPLAY_ALL:
      ldi temp2, 0xDF
      
      out PORTE, temp2
      mov temp, rMILLIS
      andi temp, 0x0F
      call CONVERT_temp_TO_SEG
      out PORTD, temp
      call SLEEP_FF
      sec
      ror temp2
      
      out PORTE, temp2
      mov temp, rSEC
      andi temp, 0x0F
      call CONVERT_temp_TO_SEG
      ori temp, 0x80
      out PORTD, temp
      call SLEEP_FF
      sec
      ror temp2
      
      out PORTE, temp2
      mov temp, rSEC
      swap temp
      andi temp, 0x0F
      call CONVERT_temp_TO_SEG
      out PORTD, temp
      call SLEEP_FF
      sec
      ror temp2
      
      ror temp2
      
      out PORTE, temp2
      mov temp, rMIN
      andi temp, 0x0F
      call CONVERT_temp_TO_SEG
      out PORTD, temp
      call SLEEP_FF
      sec
      ror temp2
      
      out PORTE, temp2
      mov temp, rMIN
      swap temp
      andi temp, 0x0F
      call CONVERT_temp_TO_SEG
      out PORTD, temp
      call SLEEP_FF
      sec
      ror temp2
      
ret
temp_BCD_TO_BYTE:
      mov temp2, temp
      swap temp2
      andi temp2, 0x0F
      ldi temp3, 0x06
      mul temp2, temp3 ; R0 := temp2 * temp3
      sub temp, R0
ret
temp_BYTE_TO_BCD:
      ldi temp3, 0x04
      ldi temp4, 0x00
      for_shifts_4:
	    mov temp2, temp
	    swap temp2
	    andi temp2, 0x0F
	    cpi temp2, 0x05
	    brlo skip_add3
		  ldi temp2, 0x30
		  add temp, temp2
	    skip_add3:
	    lsl temp
	    rol temp4
	    
      dec temp3
      cpi temp3, 0x01
      brsh for_shifts_4
      
      or temp, temp4
      swap temp
ret
;====================================================================
; PROCEDURES
;====================================================================
;OUT_temp_TO_SEG1:
;      ldi r26, 0x98;seg_table;0x98
;      add r26, temp
;      clr r27      ;Очистить старший байт X
;      ld temp, X
;      out PORTD, temp
;ret
CONVERT_temp_TO_SEG:
      ldi temp3, 0x00
      ldi ZH, high(seg_table * 2)
      ldi ZL, low(seg_table * 2)
      add ZL, temp
      adc ZH, temp3
      lpm temp, Z
ret
CONVERT_temp_TO_KBCODE:
      ldi temp2, 0xFF
      
      cpi temp, 0x80
      brlo not_row_D
      row_D:
	    andi temp, 0x0F
	    sbrc temp, 0
	    ldi temp2, 0x0F
	    sbrc temp, 1
	    ldi temp2, 0x00
	    sbrc temp, 2
	    ldi temp2, 0x0E
	    sbrc temp, 3
	    ldi temp2, 0x0A
	    jmp ret_keyboard_code
      not_row_D:
      
      cpi temp, 0x40
      brlo not_row_C
      row_C:
	    andi temp, 0x0F
	    sbrc temp, 0
	    ldi temp2, 0x01
	    sbrc temp, 1
	    ldi temp2, 0x02
	    sbrc temp, 2
	    ldi temp2, 0x03
	    sbrc temp, 3
	    ldi temp2, 0x0B
	    jmp ret_keyboard_code
      not_row_C:
      
      cpi temp, 0x20
      brlo not_row_B
      row_B:
	    andi temp, 0x0F
	    sbrc temp, 0
	    ldi temp2, 0x04
	    sbrc temp, 1
	    ldi temp2, 0x05
	    sbrc temp, 2
	    ldi temp2, 0x06
	    sbrc temp, 3
	    ldi temp2, 0x0C
	    jmp ret_keyboard_code
      not_row_B:
      
      cpi temp, 0x10
      brlo not_row_A
      row_A:
	    andi temp, 0x0F
	    sbrc temp, 0
	    ldi temp2, 0x07
	    sbrc temp, 1
	    ldi temp2, 0x08
	    sbrc temp, 2
	    ldi temp2, 0x09
	    sbrc temp, 3
	    ldi temp2, 0x0D
	    jmp ret_keyboard_code
      not_row_A:
      
      ret_keyboard_code:
      mov temp, temp2
ret
GET_KEYBOARD_PRESSED:
      ldi temp2, 0xFF
      ldi temp3, 0xF0
      ldi temp_ret, 0xFF
      
      in temp, PINB
      and temp_ret, temp
      cpse temp, temp2
      and temp3, keyboard
      call NEXT_KEYBOARD_PIN
      
      in temp, PINB
      and temp_ret, temp
      cpse temp, temp2
      and temp3, keyboard
      call NEXT_KEYBOARD_PIN
      
      in temp, PINB
      and temp_ret, temp
      cpse temp, temp2
      and temp3, keyboard
      call NEXT_KEYBOARD_PIN
      
      in temp, PINB
      and temp_ret, temp
      cpse temp, temp2
      and temp3, keyboard
      call NEXT_KEYBOARD_PIN
      
      ori temp3, 0x0F
      and temp_ret, temp3
      com temp_ret
ret
NEXT_KEYBOARD_PIN:
      sbrc keyboard, 7
      sec
      rol keyboard
      clc
      out PORTC, keyboard
ret
SLEEP_FF:
      ldi temp3, 0xFF
      wait_loop:
	    dec temp3
	    cpi temp3, 0x00
	    brne wait_loop
ret

;====================================================================
; DATA
;====================================================================
seg_table: .db 0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F
