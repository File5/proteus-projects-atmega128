;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   Вс мар 11 2018
; Processor: ATmega128
; Compiler:  AVRASM (Proteus)
;====================================================================

;====================================================================
; DEFINITIONS
;====================================================================
.def temp = R16
.def temp2 = R17
.def keyboard = R18
.def temp3 = R19
.def temp_ret = R20
.def prev_keyboard_state = R21
.def rD = R22
.def rD1 = R27
.def rA = R23
.def rA1 = R28
.def rB = R24
.def rF = R25 ; FLAGS: OV ... APPEND MUL
.def temp4 = R26
.def temp5 = R29
;====================================================================
; VARIABLES
;====================================================================

;====================================================================
; RESET and INTERRUPT VECTORS
;====================================================================

      ; Reset Vector
      rjmp  Start

;====================================================================
; CODE SEGMENT
;====================================================================

Start:
      ; Write your code here
      setup_ports:
      out_ports:
	 ldi temp, 0xFF
	 out DDRD, temp
	 out DDRE, temp
	 out DDRC, temp
      in_ports:
	 ldi temp, 0x00
	 out DDRB, temp
	 ldi temp, 0xFF
	 out PORTB, temp
	 
      out_EE_KEYBOARD:
	 ldi keyboard, 0xEE
	 out PORTC, keyboard

Loop:
      call CHECK_KEYBOARD_DOWN
      call DISPLAY_rD
      rjmp  Loop

;====================================================================
; MAIN PROCEDURES
;====================================================================
CHECK_KEYBOARD_DOWN:
      call GET_KEYBOARD_PRESSED
      cpi temp_ret, 0x00
      breq keyboard_not_pressed
      keyboard_pressed:
	    cp temp_ret, prev_keyboard_state
	    breq keyboard_not_pressed
	    keyboard_down_event:
		  mov temp, temp_ret
		  call CONVERT_temp_TO_KBCODE
		  call PRESSED_temp_KEY
      keyboard_not_pressed:
      
      mov prev_keyboard_state, temp_ret
ret
PRESSED_temp_KEY:
      cpi temp, 0x0A
      brlo digit_key
      sys_key:
	    cpi temp, 0x0F
	    breq clear_key
	    cpi temp, 0x0A
	    breq add_key
	    cpi temp, 0x0C
	    breq mul_key
	    cpi temp, 0x0E
	    breq equal_key
	    other_key:
		  jmp end_pressed_key
	    clear_key:
		  clr rD
		  clr rD1
		  clr rA
		  clr rA1
		  clr rB
		  clr rF
		  ;call DISPLAY_rD
		  jmp end_pressed_key
	    add_key:
		  sbrc rF, 1 ; skip if NOT APPEND
		  call CALC_CURRENT
		  cbr rF, 0x01 ; clear MUL
		  jmp end_pressed_key
	    mul_key:
		  sbrc rF, 1 ; skip if NOT APPEND
		  call CALC_CURRENT
		  sbr rF, 0x01 ; set MUL
		  jmp end_pressed_key
	    equal_key:
		  call CALC_CURRENT
		  cbr rF, 0x01 ; clear MUL
		  jmp end_pressed_key
      jmp end_pressed_key
      digit_key:
	    call DISPLAY_temp
	    sbr rF, 0x02 ; set APPEND
      end_pressed_key:
ret
DISPLAY_temp:
      clr rD1 ; clear rD1 always
      sbrs rF, 1 ; skip if APPEND
      eor rD, rD ; clear rD
      swap rD
      andi rD, 0xF0
      add rD, temp
      ;call DISPLAY_rD
ret
CALC_CURRENT:
      mov temp, rD
      call temp_BCD_TO_BYTE
      mov rB, temp
      
      call CALC ; A:=A OP B
      
      call rA1_rA_BYTE_TO_BCD_rD1_rD
      
      ;call DISPLAY_rD
      cbr rF, 0x02 ; clear APPEND
ret
CALC:
      sbrc rF, 0
      jmp calc_mul
      sbrs rF, 0
      jmp calc_add
      jmp end_calc
      
      calc_add:
	    add rA, rB
	    ldi temp, 0x00
	    adc rA1, temp
      jmp end_calc
      calc_mul:
	    mul rA, rB
	    mov rA, R0
	    mov rA1, R1
      jmp end_calc
      end_calc:
      cpi rA1, 0x27
      brlo end_ov_flag
      cpi rA, 0x10
      brlo end_ov_flag
	    sbr rF, 0x80
      end_ov_flag:
ret
temp_BCD_TO_BYTE:
      mov temp2, temp
      swap temp2
      andi temp2, 0x0F
      ldi temp3, 0x06
      mul temp2, temp3 ; R0 := temp2 * temp3
      sub temp, R0
ret
temp_BYTE_TO_BCD:
      ldi temp3, 0x04
      ldi temp4, 0x00
      for_shifts_4:
	    mov temp2, temp
	    swap temp2
	    andi temp2, 0x0F
	    cpi temp2, 0x05
	    brlo skip_add3
		  ldi temp2, 0x30
		  add temp, temp2
	    skip_add3:
	    lsl temp
	    rol temp4
	    
      dec temp3
      cpi temp3, 0x01
      brsh for_shifts_4
      
      or temp, temp4
      swap temp
ret
rA1_rA_BYTE_TO_BCD_rD1_rD:
      clr rD1
      clr rD
      mov temp5, rA1
      mov temp4, rA

      ldi temp3, 0x10
      for_shifts_16:
	    mov temp, rD
	    andi temp, 0x0F
	    cpi temp, 0x05
	    brlo skip_0_0
		  ldi temp2, 0x03
		  add rD, temp2
	    skip_0_0:
	    mov temp, rD
	    cpi temp, 0x50
	    brlo skip_0_1
		  ldi temp2, 0x30
		  add rD, temp2
	    skip_0_1:
	    mov temp, rD1
	    andi temp, 0x0F
	    cpi temp, 0x05
	    brlo skip_1_0
		  ldi temp2, 0x03
		  add rD1, temp2
	    skip_1_0:
	    mov temp, rD1
	    cpi temp, 0x50
	    brlo skip_1_1
		  ldi temp2, 0x30
		  add rD1, temp2
	    skip_1_1:
	    
	    lsl temp4
	    rol temp5
	    rol rD
	    rol rD1
	    
      dec temp3
      cpi temp3, 0x01
      brsh for_shifts_16
ret
;====================================================================
; PROCEDURES
;====================================================================
TEST_OUT_LED:
      mov temp, temp_ret
      call CONVERT_temp_TO_KBCODE
      swap rD
      andi rD, 0xF0
      add rD, temp
      ;call DISPLAY_rD
      ;call OUT_temp_TO_SEG1
ret
DISPLAY_rD:
      ldi temp3, 0x00
      ldi temp4, 0x00
      ldi temp2, 0xFE
      sbrs rF, 7
      andi temp2, 0x7F
      
      out PORTE, temp2
      mov temp, rD
      andi temp, 0x0F
      call CONVERT_temp_TO_SEG
      out PORTD, temp

      mov temp, rD
      swap temp
      andi temp, 0x0F
      
      call SLEEP_FF
      sec
      rol temp2
      sbrs rF, 7
      andi temp2, 0x7F

      
      out PORTE, temp2
      mov temp4, temp
      or temp4, rD1
      cpse temp4, temp3
      call CONVERT_temp_TO_SEG
      out PORTD, temp
      
      call SLEEP_FF
      sec
      rol temp2
      sbrs rF, 7
      andi temp2, 0x7F
      
      out PORTE, temp2
      mov temp, rD1
      andi temp, 0x0F
      cpse rD1, temp3
      call CONVERT_temp_TO_SEG
      out PORTD, temp
      
      mov temp, rD1
      swap temp
      andi temp, 0x0F
      
      call SLEEP_FF
      sec
      rol temp2
      sbrs rF, 7
      andi temp2, 0x7F
      
      out PORTE, temp2
      cpse temp, temp3
      call CONVERT_temp_TO_SEG
      out PORTD, temp
      
ret
;OUT_temp_TO_SEG1:
;      ldi r26, 0x98;seg_table;0x98
;      add r26, temp
;      clr r27      ;Очистить старший байт X
;      ld temp, X
;      out PORTD, temp
;ret
CONVERT_temp_TO_SEG:
      ldi temp3, 0x00
      ldi ZH, high(seg_table * 2)
      ldi ZL, low(seg_table * 2)
      add ZL, temp
      adc ZH, temp3
      lpm temp, Z
ret
CONVERT_temp_TO_KBCODE:
      ldi temp2, 0xFF
      
      cpi temp, 0x80
      brlo not_row_D
      row_D:
	    andi temp, 0x0F
	    sbrc temp, 0
	    ldi temp2, 0x0F
	    sbrc temp, 1
	    ldi temp2, 0x00
	    sbrc temp, 2
	    ldi temp2, 0x0E
	    sbrc temp, 3
	    ldi temp2, 0x0A
	    jmp ret_keyboard_code
      not_row_D:
      
      cpi temp, 0x40
      brlo not_row_C
      row_C:
	    andi temp, 0x0F
	    sbrc temp, 0
	    ldi temp2, 0x01
	    sbrc temp, 1
	    ldi temp2, 0x02
	    sbrc temp, 2
	    ldi temp2, 0x03
	    sbrc temp, 3
	    ldi temp2, 0x0B
	    jmp ret_keyboard_code
      not_row_C:
      
      cpi temp, 0x20
      brlo not_row_B
      row_B:
	    andi temp, 0x0F
	    sbrc temp, 0
	    ldi temp2, 0x04
	    sbrc temp, 1
	    ldi temp2, 0x05
	    sbrc temp, 2
	    ldi temp2, 0x06
	    sbrc temp, 3
	    ldi temp2, 0x0C
	    jmp ret_keyboard_code
      not_row_B:
      
      cpi temp, 0x10
      brlo not_row_A
      row_A:
	    andi temp, 0x0F
	    sbrc temp, 0
	    ldi temp2, 0x07
	    sbrc temp, 1
	    ldi temp2, 0x08
	    sbrc temp, 2
	    ldi temp2, 0x09
	    sbrc temp, 3
	    ldi temp2, 0x0D
	    jmp ret_keyboard_code
      not_row_A:
      
      ret_keyboard_code:
      mov temp, temp2
ret
GET_KEYBOARD_PRESSED:
      ldi temp2, 0xFF
      ldi temp3, 0xF0
      ldi temp_ret, 0xFF
      
      in temp, PINB
      and temp_ret, temp
      cpse temp, temp2
      and temp3, keyboard
      call NEXT_KEYBOARD_PIN
      
      in temp, PINB
      and temp_ret, temp
      cpse temp, temp2
      and temp3, keyboard
      call NEXT_KEYBOARD_PIN
      
      in temp, PINB
      and temp_ret, temp
      cpse temp, temp2
      and temp3, keyboard
      call NEXT_KEYBOARD_PIN
      
      in temp, PINB
      and temp_ret, temp
      cpse temp, temp2
      and temp3, keyboard
      call NEXT_KEYBOARD_PIN
      
      ori temp3, 0x0F
      and temp_ret, temp3
      com temp_ret
ret
NEXT_KEYBOARD_PIN:
      sbrc keyboard, 7
      sec
      rol keyboard
      clc
      out PORTC, keyboard
ret
SLEEP_FF:
      ldi temp3, 0xFF
      wait_loop:
	    dec temp3
	    cpi temp3, 0x00
	    brne wait_loop
ret

;====================================================================
; DATA
;====================================================================
seg_table: .db 0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F
