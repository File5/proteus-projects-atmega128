;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   —б мар 31 2018
; Processor: ATmega128
; Compiler:  AVRASM (Proteus)
;====================================================================

;====================================================================
; DEFINITIONS
;====================================================================
.def temp = R16
.def temp2 = R17
.def keyboard = R18
.def temp3 = R19
.def temp_ret = R20
.def prev_keyboard_state = R21
.def rD = R22
.def rD1 = R27
.def rA = R23
.def rA1 = R28
.def rB = R24
.def rF = R25 ; FLAGS: OV ... APPEND MUL
.def temp4 = R26
.def temp5 = R29
;====================================================================
; VARIABLES
;====================================================================

;====================================================================
; RESET and INTERRUPT VECTORS
;====================================================================

      ; Reset Vector
      rjmp  Start
      
.org 0x18
      jmp ON_TIMER

;====================================================================
; CODE SEGMENT
;====================================================================

Start:
      ; Write your code here
      setup_out_ports:
	    ldi temp, 0xFF
	    out DDRC, temp
	    out DDRD, temp
	    out DDRE, temp
      setup_in_ports:
	    ldi temp, 0x00
	    out DDRB, temp
	    ldi temp, 0xFF
	    out PORTB, temp
      out_EE_KEYBOARD:
	 ldi keyboard, 0xEE
	 out PORTC, keyboard
      setup_timer:
	    ldi temp, 0x3D
	    out OCR1AH, temp
	    ldi temp, 0x08
	    out OCR1AL, temp
	    clr temp
	    out TCCR1A, temp
	    
	    ldi temp, 0x10
	    out TIMSK, temp
	    
	    sei
      setup_timer0:
	    ldi temp, 0x23;0x1E
	    out OCR0, temp
	    sbi DDRB, 4
	    sbi PORTB, 4
Loop:
      call DISPLAY_rD
      call CHECK_KEYBOARD_DOWN
      rjmp  Loop

;====================================================================
; MAIN PROCEDURES
;====================================================================
ON_TIMER:
      call DEC_rD1_rD
      clr temp5
      or temp5, rD1
      or temp5, rD
      cpi temp5, 0x00
      brne skip_timeout
	    call STOP_TIMER
	    call RESET_TIMER
	    call START_TIMER0
      skip_timeout:
reti
RESET_TIMER:
      ldi temp5, 0x00
      out TCNT1H, temp5
      out TCNT1L, temp5
ret
START_TIMER:
      ldi temp5, 0x0B
      out TCCR1B, temp5
ret
STOP_TIMER:
      ldi temp5, 0x08
      out TCCR1B, temp5
ret
RESET_TIMER0:
      ldi temp5, 0x00
      out TCNT0, temp5
ret
START_TIMER0:
      ldi temp5, 0x1C
      out TCCR0, temp5
ret
STOP_TIMER0:
      ldi temp5, 0x18
      out TCCR0, temp5
ret
CHECK_KEYBOARD_DOWN:
      call GET_KEYBOARD_PRESSED
      cpi temp_ret, 0x00
      breq keyboard_not_pressed
      keyboard_pressed:
	    cp temp_ret, prev_keyboard_state
	    breq keyboard_not_pressed
	    keyboard_down_event:
		  mov temp, temp_ret
		  call CONVERT_temp_TO_KBCODE
		  call PRESSED_temp_KEY
      keyboard_not_pressed:
      
      mov prev_keyboard_state, temp_ret
ret
PRESSED_temp_KEY:
      cpi temp, 0x0A
      brlo digit_key
      sys_key:
	    cpi temp, 0x0F
	    breq clear_key
	    cpi temp, 0x0A
	    breq add_key
	    cpi temp, 0x0C
	    breq mul_key
	    cpi temp, 0x0E
	    breq equal_key
	    other_key:
		  jmp end_pressed_key
	    clear_key:
		  clr rD
		  clr rD1
		  clr rA
		  clr rA1
		  clr rB
		  clr rF
		  ;call DISPLAY_rD
		  call STOP_TIMER0
		  call RESET_TIMER0
		  call STOP_TIMER
		  call RESET_TIMER
		  jmp end_pressed_key
	    add_key:
		  sbrc rF, 1 ; skip if NOT APPEND
		  ;call CALC_CURRENT
		  cbr rF, 0x01 ; clear MUL
		  jmp end_pressed_key
	    mul_key:
		  sbrc rF, 1 ; skip if NOT APPEND
		  ;call CALC_CURRENT
		  sbr rF, 0x01 ; set MUL
		  jmp end_pressed_key
	    equal_key:
		  ;call CALC_CURRENT
		  call START_TIMER
		  cbr rF, 0x01 ; clear MUL
		  jmp end_pressed_key
      jmp end_pressed_key
      digit_key:
	    call DISPLAY_temp
	    sbr rF, 0x02 ; set APPEND
      end_pressed_key:
ret
DISPLAY_temp:
      ;clr rD1 ; clear rD1 always
      mov temp2, rF
      andi temp2, 0x02
      cpi temp2, 0x00
      brne skip_clr_display ; skip if APPEND
      eor rD, rD ; clear rD
      skip_clr_display:
      mov temp2, rD
      andi temp2, 0xF0
      andi rD1, 0x0F
      add rD1, temp2
      swap rD1
      swap rD
      andi rD, 0xF0
      add rD, temp
      ;call DISPLAY_rD
ret
DEC_rD1_rD:
      dec rD
      
      mov temp5, rD
      cpi temp5, 0xFF
      brne skip_dec_rD1
	    ldi rD, 0x59
	    
	    dec rD1
	    
	    cpi rD1, 0xFF
	    brne skip_rD1_99
		  ldi rD1, 0x59
	    skip_rD1_99:
	    
	    mov temp5, rD1
	    andi temp5, 0x0F
	    cpi temp5, 0x0F
	    brne skip_correction_rD1
		  ldi temp5, 0x06
		  sub rD1, temp5
	    skip_correction_rD1:
      skip_dec_rD1:
      
      mov temp5, rD
      andi temp5, 0x0F
      cpi temp5, 0x0F
      brne skip_correction_rD
	    ldi temp5, 0x06
	    sub rD, temp5
      skip_correction_rD:
ret
temp_BCD_TO_BYTE:
      mov temp2, temp
      swap temp2
      andi temp2, 0x0F
      ldi temp3, 0x06
      mul temp2, temp3 ; R0 := temp2 * temp3
      sub temp, R0
ret
temp_BYTE_TO_BCD:
      ldi temp3, 0x04
      ldi temp4, 0x00
      for_shifts_4:
	    mov temp2, temp
	    swap temp2
	    andi temp2, 0x0F
	    cpi temp2, 0x05
	    brlo skip_add3
		  ldi temp2, 0x30
		  add temp, temp2
	    skip_add3:
	    lsl temp
	    rol temp4
	    
      dec temp3
      cpi temp3, 0x01
      brsh for_shifts_4
      
      or temp, temp4
      swap temp
ret
rA1_rA_BYTE_TO_BCD_rD1_rD:
      clr rD1
      clr rD
      mov temp5, rA1
      mov temp4, rA

      ldi temp3, 0x10
      for_shifts_16:
	    mov temp, rD
	    andi temp, 0x0F
	    cpi temp, 0x05
	    brlo skip_0_0
		  ldi temp2, 0x03
		  add rD, temp2
	    skip_0_0:
	    mov temp, rD
	    cpi temp, 0x50
	    brlo skip_0_1
		  ldi temp2, 0x30
		  add rD, temp2
	    skip_0_1:
	    mov temp, rD1
	    andi temp, 0x0F
	    cpi temp, 0x05
	    brlo skip_1_0
		  ldi temp2, 0x03
		  add rD1, temp2
	    skip_1_0:
	    mov temp, rD1
	    cpi temp, 0x50
	    brlo skip_1_1
		  ldi temp2, 0x30
		  add rD1, temp2
	    skip_1_1:
	    
	    lsl temp4
	    rol temp5
	    rol rD
	    rol rD1
	    
      dec temp3
      cpi temp3, 0x01
      brsh for_shifts_16
ret
;====================================================================
; PROCEDURES
;====================================================================
TEST_OUT_LED:
      mov temp, temp_ret
      call CONVERT_temp_TO_KBCODE
      swap rD
      andi rD, 0xF0
      add rD, temp
      ;call DISPLAY_rD
      ;call OUT_temp_TO_SEG1
ret
DISPLAY_rD:
      ldi temp3, 0x00
      ldi temp4, 0x00
      ldi temp2, 0xFE
      sbrs rF, 7
      andi temp2, 0x7F
      
      out PORTE, temp2
      mov temp, rD
      andi temp, 0x0F
      call CONVERT_temp_TO_SEG
      out PORTD, temp

      mov temp, rD
      swap temp
      andi temp, 0x0F
      
      call SLEEP_FF
      sec
      rol temp2
      sbrs rF, 7
      andi temp2, 0x7F

      
      out PORTE, temp2
      mov temp4, temp
      or temp4, rD1
      ;cpse temp4, temp3 ; WHEN LEADING ZERO - DO NOT OUT
      call CONVERT_temp_TO_SEG
      out PORTD, temp
      
      call SLEEP_FF
      sec
      rol temp2
      sbrs rF, 7
      andi temp2, 0x7F
      
      out PORTE, temp2
      mov temp, rD1
      andi temp, 0x0F
      ;cpse rD1, temp3 ; WHEN LEADING ZERO - DO NOT OUT
      call CONVERT_temp_TO_SEG
      ldi temp4, 0x80
      add temp, temp4 ; ALWAYS SHOW DP ON 3rd 7SEG
      out PORTD, temp
      
      mov temp, rD1
      swap temp
      andi temp, 0x0F
      
      call SLEEP_FF
      sec
      rol temp2
      sbrs rF, 7
      andi temp2, 0x7F
      
      out PORTE, temp2
      ;cpse temp, temp3 ; WHEN LEADING ZERO - DO NOT OUT
      call CONVERT_temp_TO_SEG
      out PORTD, temp
      
      call SLEEP_FF
ret
;OUT_temp_TO_SEG1:
;      ldi r26, 0x98;seg_table;0x98
;      add r26, temp
;      clr r27      ;ќчистить старший байт X
;      ld temp, X
;      out PORTD, temp
;ret
CONVERT_temp_TO_SEG:
      ldi temp3, 0x00
      ldi ZH, high(seg_table * 2)
      ldi ZL, low(seg_table * 2)
      add ZL, temp
      adc ZH, temp3
      lpm temp, Z
ret
CONVERT_temp_TO_KBCODE:
      ldi temp2, 0xFF
      
      cpi temp, 0x80
      brlo not_row_D
      row_D:
	    andi temp, 0x0F
	    sbrc temp, 0
	    ldi temp2, 0x0F
	    sbrc temp, 1
	    ldi temp2, 0x00
	    sbrc temp, 2
	    ldi temp2, 0x0E
	    sbrc temp, 3
	    ldi temp2, 0x0A
	    jmp ret_keyboard_code
      not_row_D:
      
      cpi temp, 0x40
      brlo not_row_C
      row_C:
	    andi temp, 0x0F
	    sbrc temp, 0
	    ldi temp2, 0x07
	    sbrc temp, 1
	    ldi temp2, 0x08
	    sbrc temp, 2
	    ldi temp2, 0x09
	    sbrc temp, 3
	    ldi temp2, 0x0D
	    jmp ret_keyboard_code
      not_row_C:
      
      cpi temp, 0x20
      brlo not_row_B
      row_B:
	    andi temp, 0x0F
	    sbrc temp, 0
	    ldi temp2, 0x04
	    sbrc temp, 1
	    ldi temp2, 0x05
	    sbrc temp, 2
	    ldi temp2, 0x06
	    sbrc temp, 3
	    ldi temp2, 0x0C
	    jmp ret_keyboard_code
      not_row_B:
      
      cpi temp, 0x10
      brlo not_row_A
      row_A:
	    andi temp, 0x0F
	    sbrc temp, 0
	    ldi temp2, 0x01
	    sbrc temp, 1
	    ldi temp2, 0x02
	    sbrc temp, 2
	    ldi temp2, 0x03
	    sbrc temp, 3
	    ldi temp2, 0x0B
	    jmp ret_keyboard_code
      not_row_A:
      
      ret_keyboard_code:
      mov temp, temp2
ret
GET_KEYBOARD_PRESSED:
      ldi temp2, 0xFF
      ldi temp3, 0xF0
      ldi temp_ret, 0xFF
      
      in temp, PINB
      ori temp, 0xF0
      and temp_ret, temp
      cpse temp, temp2
      and temp3, keyboard
      call NEXT_KEYBOARD_PIN
      
      in temp, PINB
      ori temp, 0xF0
      and temp_ret, temp
      cpse temp, temp2
      and temp3, keyboard
      call NEXT_KEYBOARD_PIN
      
      in temp, PINB
      ori temp, 0xF0
      and temp_ret, temp
      cpse temp, temp2
      and temp3, keyboard
      call NEXT_KEYBOARD_PIN
      
      in temp, PINB
      ori temp, 0xF0
      and temp_ret, temp
      cpse temp, temp2
      and temp3, keyboard
      call NEXT_KEYBOARD_PIN
      
      ori temp3, 0x0F
      and temp_ret, temp3
      com temp_ret
ret
NEXT_KEYBOARD_PIN:
      sbrc keyboard, 7
      sec
      rol keyboard
      clc
      out PORTC, keyboard
ret
SLEEP_FF:
      ldi temp3, 0xFF
      wait_loop:
	    dec temp3
	    cpi temp3, 0x00
	    brne wait_loop
ret

;====================================================================
; DATA
;====================================================================
seg_table: .db 0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F
